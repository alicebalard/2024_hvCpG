labs(title = "Probability of being hypervariable",
x = "P(hv) considering all array data",
y = "P(hv) considering all WGBS atlas data")+
scale_x_continuous(breaks = seq(0, 1, by = .1))+
scale_y_continuous(breaks = seq(0, 1, by = .1))
p1 <- ggplot(res_Alpha_Atlas, aes(x=alpha_array_all, y=alpha_atlas)) +
geom_point(pch = 21, alpha = 0.05) +
geom_abline(slope = 1, linetype = 3) +
geom_smooth(method = "lm", fill = "black") +
theme_minimal(base_size = 14) +
guides(fill = guide_legend(position = "inside"))+
theme(legend.position.inside = c(0.18,0.85),
legend.box = "horizontal", legend.title = element_blank(),
legend.background = element_rect(fill = "white", color = "black", linewidth = 0.4),
legend.key = element_rect(fill = "white", color = NA)) +
labs(title = "Probability of being hypervariable",
x = "P(hv) considering all array data",
y = "P(hv) considering all WGBS atlas data") +
scale_x_continuous(breaks = seq(0, 1, by = .1)) +
scale_y_continuous(breaks = seq(0, 1, by = .1))
pdf(here("05_hvCpGalgorithm/figures/correlation_array_atlas.pdf"), width = 5, height = 5)
p1
dev.off()
summary(lm(alpha_atlas ~ alpha_array_all, data = res_Alpha_Atlas))
mod <- lm(alpha_atlas ~ alpha_array_all, data = res_Alpha_Atlas)
mod
mod$coefficients
mod$coefficients["alpha_array_all"]
corelCoef <- mod$coefficients["alpha_array_all"]
summary(mod)
correlCoef <- mod$coefficients["alpha_array_all"]
rm(corelCoef)
## Venn
x <- list("atlas +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.8 * correlCoef],
"array +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_array_all > 0.8])
y <- list("atlas +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.9 * correlCoef],
"array +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_array_all > 0.9])
p1 <- ggVennDiagram(x, label_alpha = 0) +  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")+
guides(fill = "none")
p2 <- ggVennDiagram(y, label_alpha = 0) +  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")+
guides(fill = "none")
labels = c("p(hv) > 0.8 (x0.42)", "p(hv) > 0.9 (x0.42)")
# 2D Venn diagram
ggsave(here("05_hvCpGalgorithm/figures/TP-FP-arrayAtlas.pdf"),
plot = p,
width = 15, height = 5)
## Male only atlas
atlas_dt_male <- mergeAtlasRunBatches(parent_dir = "05_hvCpGalgorithm/resultsDir/10X_males/",
analysis = "Atlas10X_males", alphaname = "alpha_atlas_males")
p <- cowplot::plot_grid(p1,p2, ncol = 2,
labels = c("p(hv) > 0.8 (x0.42)", "p(hv) > 0.9 (x0.42)"))
# 2D Venn diagram
ggsave(here("05_hvCpGalgorithm/figures/TP-FP-arrayAtlas.pdf"),
plot = p,
width = 15, height = 5)
y <- list("atlas +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.95 * correlCoef],
"array +" = res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_array_all > 0.95])
p1 <- ggVennDiagram(x, label_alpha = 0) +  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")+
guides(fill = "none")
p2 <- ggVennDiagram(y, label_alpha = 0) +  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")+
guides(fill = "none")
p <- cowplot::plot_grid(p1,p2, ncol = 2,
labels = c("p(hv) > 0.8 (x0.42)", "p(hv) > 0.9 (x0.42)"))
# 2D Venn diagram
ggsave(here("05_hvCpGalgorithm/figures/TP-FP-arrayAtlas.pdf"),
plot = p,
width = 15, height = 5)
res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.8
res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.8]
res_Alpha_Atlas$chrpos[res_Alpha_Atlas$alpha_atlas > 0.8]
res_Alpha_Atlas$alpha_array_all[res_Alpha_Atlas$alpha_atlas > 0.8]
na.omit(res_Alpha_Atlas$alpha_array_all[res_Alpha_Atlas$alpha_atlas > 0.8])
hist(res_Alpha_Atlas$alpha_array_all[res_Alpha_Atlas$alpha_atlas > 0.8])
hist(res_Alpha_Atlas$alpha_array_all[res_Alpha_Atlas$alpha_atlas > 0.8], breaks = 100)
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram()
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram() +
scale_y_log10()
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram() +
scale_y_sqrt()
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram()
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram()+
theme_minimal(base_size = 14)
ggplot(data = res_Alpha_Atlas[res_Alpha_Atlas$alpha_atlas > 0.8,], aes(x = alpha_array_all)) +
geom_histogram()+
theme_minimal(base_size = 14) +
xlab("p(hv) in array")
df_plot <- bind_rows(
res_Alpha_Atlas %>% filter(alpha_atlas > 0.8) %>% mutate(threshold = "> 0.8"),
res_Alpha_Atlas %>% filter(alpha_atlas > 0.7) %>% mutate(threshold = "> 0.7"),
res_Alpha_Atlas %>% filter(alpha_atlas > 0.6) %>% mutate(threshold = "> 0.6")
)
ggplot(df_plot, aes(x = alpha_array_all)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white") +
facet_wrap(~threshold, ncol = 1, scales = "free_y") +
theme_minimal(base_size = 14) +
xlab("p(hv) in array") +
ylab("Count")
ggplot(df_plot, aes(x = alpha_array_all)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white") +
# facet_wrap(~threshold, ncol = 1, scales = "free_y") +
theme_minimal(base_size = 14) +
xlab("p(hv) in array") +
ylab("Count")
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white") +
# facet_wrap(~threshold, ncol = 1, scales = "free_y") +
theme_minimal(base_size = 14) +
xlab("p(hv) in array") +
ylab("Count")
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30,color = "white") +
# facet_wrap(~threshold, ncol = 1, scales = "free_y") +
theme_minimal(base_size = 14) +
xlab("p(hv) in array") +
ylab("Count")
pdf(here("05_hvCpGalgorithm/figures/histCutoff-arrayAtlas.pdf"), width = 10, height = 5)
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30,color = "white") +
theme_minimal(base_size = 14) +
xlab("p(hv) in array") +
ylab("Count")
dev.off()
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30,color = "white") +
theme_minimal(base_size = 14) +
scale_fill_manual(values = c("yellow", "orange", "red"))
pdf(here("05_hvCpGalgorithm/figures/histCutoff-arrayAtlas.pdf"), width = 10, height = 5)
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30,color = "white") +
theme_minimal(base_size = 14) +
scale_fill_manual(values = c("yellow", "orange", "red"))+
xlab("p(hv) in array") +
ylab("Count")
dev.off()
df_plot
table(df_plot$threshold)
pdf(here("05_hvCpGalgorithm/figures/histCutoff-arrayAtlas.pdf"), width = 8, height = 5)
ggplot(df_plot, aes(x = alpha_array_all, fill=threshold)) +
geom_histogram(bins = 30,color = "white") +
theme_minimal(base_size = 14) +
scale_fill_manual(values = c("yellow", "orange", "red"))+
xlab("p(hv) in array") +
ylab("Count")
dev.off()
##############
threshold=0.7#
# Filter valid rows
dt_clean <- Atlas_dt[!is.na(start_pos) & !is.na(end_pos)]
rm(Atlas_dt)
# Create GRanges
gr_cpg <- GRanges(
seqnames = paste0("chr", dt_clean$chr),
ranges = IRanges(start = dt_clean$start_pos, end = dt_clean$end_pos),
alpha = dt_clean$alpha
)
# Import bed file
bed_features <- genomation::readTranscriptFeatures(
"~/Documents/Project_hvCpG/hg38_GENCODE_V47.bed")
# annotate CpGs with high alpha (>threshold):
anno_result_highalpha <- genomation::annotateWithGeneParts(
target = gr_cpg[!is.na(mcols(gr_cpg)$alpha) & mcols(gr_cpg)$alpha > threshold],
feature = bed_features)
# annotate CpGs with low alpha (<=threshold):
anno_result_lowalpha <- genomation::annotateWithGeneParts(
target = gr_cpg[!is.na(mcols(gr_cpg)$alpha) & mcols(gr_cpg)$alpha <= threshold],
feature = bed_features)
# Percentages from annotations
low_anno <- anno_result_lowalpha@precedence
high_anno <- anno_result_highalpha@precedence
## Convert percentages to counts
N_low <- nrow(dt_clean[alpha <= threshold])
N_high <- nrow(dt_clean[alpha > threshold])
# Reconstruct counts from percentages
count_low <- round(low_anno / 100 * N_low)
count_high <- round(high_anno / 100 * N_high)
## Build contingency table
contingency <- rbind(
LowAlpha = count_low,
HighAlpha = count_high
)
print(contingency)
##  Perform chi-squared test
chisq.test(contingency)
################
## Barplot ##
df_plot <- as.data.frame(contingency) %>%
tibble::rownames_to_column("AlphaGroup") %>%
tidyr::pivot_longer(-AlphaGroup, names_to = "Region", values_to = "Count") %>%
group_by(AlphaGroup) %>%
mutate(Percent = Count / sum(Count) * 100)
pdf(here("05_hvCpGalgorithm/figures/barplotFeaturesLowHighAlpha.pdf"), width = 5, height = 4)
ggplot(df_plot, aes(x=Region, y=Percent, fill = AlphaGroup))+
geom_bar(position="dodge", stat="identity") +
theme_minimal(base_size = 14)+
scale_fill_manual(
values = c("red", "skyblue"),
name = "p(hypervariable)",      # optional
labels = c(">75%", "<=75%")   # new names for legend keys
) +
theme(axis.title.x = element_blank())
dev.off()
rm(anno_result_highalpha, anno_result_lowalpha)
ggplot(df_plot, aes(x=Region, y=Percent, fill = AlphaGroup))+
geom_bar(position="dodge", stat="identity") +
theme_minimal(base_size = 14)+
scale_fill_manual(
values = c("red", "skyblue"),
name = "p(hypervariable)",      # optional
labels = c(">7%", "<=7%")   # new names for legend keys
) +
theme(axis.title.x = element_blank())
pdf(here("05_hvCpGalgorithm/figures/barplotFeaturesLowHighAlpha.pdf"), width = 5, height = 4)
ggplot(df_plot, aes(x=Region, y=Percent, fill = AlphaGroup))+
geom_bar(position="dodge", stat="identity") +
theme_minimal(base_size = 14)+
scale_fill_manual(
values = c("red", "skyblue"),
name = "p(hypervariable)",      # optional
labels = c(">7%", "<=7%")   # new names for legend keys
) +
theme(axis.title.x = element_blank())
dev.off()
pdf(here("05_hvCpGalgorithm/figures/barplotFeaturesLowHighAlpha.pdf"), width = 5, height = 4)
ggplot(df_plot, aes(x=Region, y=Percent, fill = AlphaGroup))+
geom_bar(position="dodge", stat="identity") +
theme_minimal(base_size = 14)+
scale_fill_manual(
values = c("red", "skyblue"),
name = "p(hv)",      # optional
labels = c(">7%", "<=7%")   # new names for legend keys
) +
theme(axis.title.x = element_blank())
dev.off()
pdf(here("05_hvCpGalgorithm/figures/barplotFeaturesLowHighAlpha.pdf"), width = 5, height = 4)
ggplot(df_plot, aes(x=Region, y=Percent, fill = AlphaGroup))+
geom_bar(position="dodge", stat="identity") +
theme_minimal(base_size = 14)+
scale_fill_manual(
values = c("red", "skyblue"),
name = "p(hv)",      # optional
labels = c(">70%", "<=70%")   # new names for legend keys
) +
theme(axis.title.x = element_blank())
dev.off()
#######################################
## Harris2012_1776SIV_10children450k ##
HarrisSIV <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/Harris2012_1776SIV_10children450k.xls"), sheet = 3)
HarrisSIV_hg38 <- hvCpGandControls$dictionary[
match(HarrisSIV$Probe, hvCpGandControls$dictionary$illu450k), "hg38"]
HarrisSIV_hg38 <- na.omit(HarrisSIV_hg38)
length(HarrisSIV_hg38) # 1773
###########################
## VanBaak2018_ESS_HM450 ##
VanBaakESS <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/VanBaak2018_1580ESS_450k.xlsx"), sheet = 2)
## only ESS hits
VanBaakESS <- VanBaakESS[VanBaakESS$`ESS hit`,]
VanBaakESS_hg38 <- hvCpGandControls$dictionary[
match(VanBaakESS$CG, hvCpGandControls$dictionary$illu450k), "hg38"]
VanBaakESS_hg38 <- na.omit(VanBaakESS_hg38)
length(VanBaakESS_hg38) # 1579
###########################################
## Kessler2018_687SIVregions_2WGBS hg19! ##
KesslerSIV <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/Kessler2018_supTables.xlsx"), sheet = 2, skip = 1)
KesslerSIV_GRanges <- GRanges(
seqnames = KesslerSIV$Chromosome,
ranges = IRanges(start = KesslerSIV$`ME start`,
end = KesslerSIV$`ME end`),
strand = "*")
## liftover to hg38, keep uniquely mapping regions
mapped <- liftOver(KesslerSIV_GRanges, hvCpGandControls$chain)
keep <- lengths(mapped) == 1
hg38_unique <- unlist(mapped[keep])
## find the match with Atlas cpg
cpg_46 <- read.table("~/Documents/Project_hvCpG/selected_cpgs_min3_in46_datasets.txt")$V1
# Parse with regex
parsed <- str_match(cpg_46, "(chr[0-9XYM]+)_(\\d+)-(\\d+)")
# Build GRanges
cpg_46_GR <- GRanges(
seqnames = parsed[,2],
ranges   = IRanges(start = as.numeric(parsed[,3]),
end   = as.numeric(parsed[,4]))
)
overlaps <- findOverlaps(query = KesslerSIV_GRanges, subject = cpg_46_GR)
# Extract the overlapping ranges
CpG_overlapping     <- cpg_46_GR[subjectHits(overlaps)]
KesslerSIV_hg38 <- paste0(CpG_overlapping@seqnames, "_", CpG_overlapping@ranges)
KesslerSIV_hg38 <- na.omit(KesslerSIV_hg38)
length(KesslerSIV_hg38) # 819
#######################################
## Gunasekara2019_9926CoRSIVs_10WGBS ##
# Load corSIV intervals (already in hg38)
corSIV <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/Gunasekara2019_9926CoRSIVs_10WGBS.xls"), sheet = 3)
corSIV <- unique(corSIV$USCS_Coordinates_CoRSIV)
corSIV_split <- tstrsplit(corSIV, "[:-]", fixed = FALSE)
corSIV_GRanges_hg38 <- GRanges(
seqnames = corSIV_split[[1]],
ranges = IRanges(start = as.integer(corSIV_split[[2]]), end = as.integer(corSIV_split[[3]])),
strand = "*")
## find the match with Atlas cpg
overlaps <- findOverlaps(query = corSIV_GRanges_hg38, subject = cpg_46_GR)
CpG_overlapping     <- cpg_46_GR[subjectHits(overlaps)]
corSIV_hg38 <- paste0(CpG_overlapping@seqnames, "_", CpG_overlapping@ranges)
corSIV_hg38 <- na.omit(corSIV_hg38)
length(corSIV_hg38) # 70352
#######################################
## Silver2022_SoCCpGs_10WGBS ##
arrayRef <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/Silver2022_259SoC_hg19.xlsx"), sheet = 3, skip = 2)
SoCCpGs <- readxl::read_excel(here("05_hvCpGalgorithm/dataPrev/Silver2022_259SoC_hg19.xlsx"), sheet = 6, skip = 2)
SoCCpGs_GRanges <- GRanges(
seqnames = paste0("chr", arrayRef$chr[match(SoCCpGs$cpg, arrayRef$cpg)]),
ranges = IRanges(start = arrayRef$loc[match(SoCCpGs$cpg, arrayRef$cpg)],
end = arrayRef$loc[match(SoCCpGs$cpg, arrayRef$cpg)] + 1),
strand = "*")
## liftover to hg38, keep uniquely mapping regions
mapped <- liftOver(SoCCpGs_GRanges, hvCpGandControls$chain)
keep <- lengths(mapped) == 1
hg38_unique <- unlist(mapped[keep])
## find the match with Atlas cpg
overlaps <- findOverlaps(query = hg38_unique, subject = cpg_46_GR)
CpG_overlapping     <- cpg_46_GR[subjectHits(overlaps)]
SoCCpGs_hg38 <- paste0(CpG_overlapping@seqnames, "_", CpG_overlapping@ranges)
SoCCpGs_hg38 <- na.omit(SoCCpGs_hg38)
length(SoCCpGs_hg38) #177
#################################
## Check overlaps with upset plot
sets <- list(
HarrisSIV = HarrisSIV_hg38,
VanBaakESS = VanBaakESS_hg38,
KesslerSIV = KesslerSIV_hg38,
CoRSIV = corSIV_hg38,
SoCCpGs = SoCCpGs_hg38,
hvCpG = hvCpGandControls$DerakhshanhvCpGs_names,
mQTLcontrols = hvCpGandControls$mQTLcontrols_names
)
# Create the plot in a base graphics device
pdf(NULL)  # draw to null device to avoid displaying
upset(fromList(sets), nsets = 7, order.by = "freq")
grid_plot <- grid.grab()  # Capture as a grid object
dev.off()
# Now save the captured grid object to a real PDF
pdf(here("05_hvCpGalgorithm/figures/upsetPreviousME.pdf"), width = 12, height = 5)
grid.draw(grid_plot)
dev.off()
MEsetdt <- rbindlist(lapply(names(sets), function(nm) {
dt_clean[.(sets[[nm]]), on = .(name), .(name, alpha)][, ME := nm]
}))
MEsetdt <- na.omit(MEsetdt) ## 33478 so far (2 sept)
## Control as baseline
MEsetdt[, ME := relevel(factor(ME), ref = "mQTLcontrols")]
p1 <- ggplot(MEsetdt, aes(x = ME, y = alpha)) +
geom_jitter(data = MEsetdt,
aes(fill=ME), pch=21, size = 3, alpha = .1)+
geom_violin(aes(col=ME))+
geom_boxplot(aes(col=ME), width = .1) +
theme_minimal(base_size = 14) +
theme(legend.position = "none", axis.title.x = element_blank()) +
ylab("Probability of being a hvCpG")
p1
# 1️⃣ Fit the model with mQTLcontrols as baseline
fit <- lm(alpha ~ ME, data = MEsetdt)
# 2️⃣ Get estimated marginal means and contrasts vs baseline
emm <- emmeans(fit, ~ ME)
contrasts <- contrast(emm, method = "trt.vs.ctrl", ref = "mQTLcontrols", adjust = "sidak") %>%
as.data.frame()
# 3️⃣ Prepare for plotting
contrasts <- contrasts %>%
mutate(ME = contrast,  # rename for clarity
lower = estimate - 1.96*SE,
upper = estimate + 1.96*SE)
# 4️⃣ Plot
p2 <- ggplot(contrasts, aes(x = ME, y = estimate)) +
geom_point(size = 3) +
geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
coord_flip() +
labs(
y = "Difference in alpha vs mQTLcontrols",
x = "ME group",
title = "Comparison of ME groups to mQTLcontrols",
subtitle = "lm with multiple comparison correction (Sidak)"
) +
theme_minimal()
pdf(here("05_hvCpGalgorithm/figures/alphaComparisonBetweenMEtypes.pdf"), width = 13, height = 4)
cowplot::plot_grid(p1,p2, rel_widths = c(1, .8))
dev.off()
MEsetdt
names(dt_clean)
#################################
### Regions of hypervariation ###
#################################
alphadt_ME <- left_join(dt_clean, MEsetdt)
alphadt_MEprev <- alphadt_ME
rm(alphadt_ME)
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev,
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.01, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas.pdf"), width = 15, height = 3)
dev.off()
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
alphadt_MEprev$ME
is.na(alphadt_MEprev$ME)
alphadt_MEprev[is.na(alphadt_MEprev$ME)]
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev[is.na(alphadt_MEprev$ME)],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = alphadt_MEprev[!is.na(alphadt_MEprev$ME)],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
table(alphadt_MEprev$ME)
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev[is.na(alphadt_MEprev$ME) & alphadt_MEprev$ME %in% "mQTLcontrols",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = alphadt_MEprev[!is.na(alphadt_MEprev$ME) & !alphadt_MEprev$ME %in% "mQTLcontrols",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev[is.na(alphadt_MEprev$ME) | alphadt_MEprev$ME %in% "mQTLcontrols",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = alphadt_MEprev[!is.na(alphadt_MEprev$ME) & !alphadt_MEprev$ME %in% "mQTLcontrols",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev[!alphadt_MEprev$ME %in% "CoRSIV",],
aes(x = pos2, y = alpha), color = "black",
size = 0.01, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = alphadt_MEprev[alphadt_MEprev$ME %in% "CoRSIV",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
plot <- ggplot() +
geom_point_rast(data = alphadt_MEprev[!alphadt_MEprev$ME %in% "CoRSIV",],
aes(x = pos2, y = alpha), color = "black",
size = 0.01, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = alphadt_MEprev[alphadt_MEprev$ME %in% "CoRSIV",],
aes(x = pos2, y = alpha, color = ME),
size = 0.01, alpha = 0.05, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
#################################
### Regions of hypervariation ###
#################################
plot <- ggplot() +
geom_point_rast(data = dt_clean, aes(x = pos2, y = alpha), color = "black",
size = 0.01, alpha = 0.01, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = as.character(df2$chr), expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
labs(x = "Chromosome", y = "Probability of being a hvCpG")+
theme_minimal(base_size = 14)
# Save as PDF — rasterization improves performance and file size
CairoPDF(here("05_hvCpGalgorithm/figures/ManhattanAlphaPlot_atlas_2.pdf"), width = 15, height = 3)
print(plot)
dev.off()
