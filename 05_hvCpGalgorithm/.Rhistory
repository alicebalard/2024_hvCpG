# Points
geom_point_rast(data = dt, aes(x = pos2, y = alpha), color = "white", size = 0.3, alpha = 0.01, raster.dpi = 72) +
# Axis & theme
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center, labels = c(1:15,"",17,"",19,"",21,"")) +
xlab("Chromosome") + ylab("Alpha value")
## Manhattan plot:
mplot <- ggplot(dt,aes(x=pos2,y=alpha,colour=as.character(chr)))+
geom_point_rast(size = 0.3, alpha = 0.01, raster.dpi = 72)+
scale_colour_manual(values=setNames(rep(c(colour1, colour2), length.out = 22),
as.character(1:22)))+
theme_classic() + theme(legend.position="none")+
scale_x_continuous(breaks=df2$center,labels=c(1:15,"",17,"",19,"",21,""))+
xlab("Chromosome")
Cairo::CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(mplot)
## July 2025
## A. Balard
## Plot files for scan Atlas
## First test: 10X coverage in at least 3 individuals in at least 3 datasets
## 5G, 5T, run on cs cluster in 2 days for everything (29M CpG sites)
# Load required libraries
library(data.table)  # for fast processing
library(progress)   # progress bar
# Define parent folder containing all "Atlas_batchXXX" folders
parent_dir <- "resultsDir"
# Get list of all relevant file paths (assumes one RData per folder)
rdata_files <- dir(parent_dir, pattern = "results_Atlas_100000CpGs_0_8p0_0_65p1\\.RData$",
recursive = TRUE, full.names = TRUE)
# Initialize empty vector to collect results
all_cpg_values <- numeric()  # named numeric vector
# Optional: progress bar
pb <- progress_bar$new(total = length(rdata_files), format = "ðŸ“¦ :current/:total [:bar] :percent")
# Loop through and load each RData file
for (file in rdata_files) {
# Load into a temporary environment to avoid cluttering workspace
e <- new.env()
load(file, envir = e)
# Assume thereâ€™s only one object in each file
obj <- e[[ls(e)[1]]]
# If it's a matrix, convert to vector while keeping names
if (is.matrix(obj)) obj <- obj[, 1]
# Append to final result
all_cpg_values <- c(all_cpg_values, obj)
pb$tick()
}
# Check result
length(all_cpg_values)      # Should be 29,000,000
head(all_cpg_values)
summary(all_cpg_values)
hist(all_cpg_values, breaks = 100)
head(all_cpg_values)
library(data.table)
# all_cpg_values is a named numeric vector
dt <- data.table(
name = names(all_cpg_values),
alpha = as.numeric(all_cpg_values)
)
# Fast column splitting into chr/start/end
dt[, c("chr", "start_end") := tstrsplit(name, "_", fixed = TRUE)]
dt[, c("start_pos", "end_pos") := tstrsplit(start_end, "-", fixed = TRUE)]
dt[, `:=`(
start_pos = as.integer(start_pos),
end_pos = as.integer(end_pos)
)]
library(data.table)
library(ggplot2)
library(ggrastr)
library(patchwork)
head(dt,4)
# chr   pos   pval
#   1 12345 0.9882
#   1 12349 0.6454
#   1 12368 0.8322
#   1 12552 0.2339
# Strip "chr" prefix to get numeric ordering
dt[, chr := as.integer(sub("chr", "", chr))]
table(dt$chr)
# Order the factor by chromosome number
dt[, chr := factor(chr, levels = 1:22)]
table(dt$chr)
## Calculate cumulative value of position, the position on X-axis on Manhattan plot
### Assume dt has columns: chr (factor), pos (numeric), and we want to compute pos2 (numeric)
setorder(dt, chr, start_pos)  # ensure sorting
# Step 1: Compute chromosome-wise max(pos)
offsets <- dt[, .(max_pos = max(start_pos, na.rm = TRUE)), by = chr]
# Step 2: Create cumulative offsets
offsets[, cum_offset := shift(cumsum(max_pos), fill = 0)]
# Step 3: Merge offsets back to dt and compute pos2
dt <- merge(dt, offsets[, .(chr, cum_offset)], by = "chr", all.x = TRUE, sort = FALSE)
dt[, pos2 := start_pos + cum_offset]
## Calculate center positions of each chromosome on X-axis = positions of chromosome numbers
# Step 1: Compute center positions by chromosome
df2 <- dt[, .(
center = mean(range(pos2, na.rm = TRUE))
), by = chr]
# Step 2: (Optional) Ensure it's a data.frame with chr 1â€“22
df2 <- merge(
data.frame(chr = 1:22),
df2, by = "chr", all.x = TRUE, sort = TRUE
)
## Add corSIV info (also on hg38)
corSIV <- readxl::read_excel("13059_2019_1708_MOESM1_ESM.xls",sheet = 3)
corSIV <- unique(corSIV$USCS_Coordinates_CoRSIV)
# Split CoRSIV entries like "chr1:630100-630700"
corSIV_dt <- data.table(coord = corSIV)
corSIV_dt[, c("chr", "range") := tstrsplit(coord, ":", fixed = TRUE)]
corSIV_dt[, c("start", "end") := tstrsplit(range, "-", fixed = TRUE)]
corSIV_dt[, `:=`(
chr = as.integer(sub("chr", "", chr)),
start = as.integer(start),
end = as.integer(end)
)]
# Merge CoRSIVs with cumulative offsets per chromosome
# Ensure both are integer before the merge
offsets[, chr := as.integer(as.character(chr))]
# Now the join will succeed
corSIV_dt <- merge(corSIV_dt, offsets, by = "chr", all.x = TRUE)
corSIV_dt[, `:=`(
xmin = start + cum_offset,
xmax = end + cum_offset
)]
## Make a repeating pattern of two colors
colour1="#2e4057"
colour2="#8c8c8c"
## Manhattan plot:
mplot <- ggplot(dt,aes(x=pos2,y=alpha,colour=as.character(chr)))+
geom_point_rast(size = 0.3, alpha = 0.01, raster.dpi = 72)+
scale_colour_manual(values=setNames(rep(c(colour1, colour2), length.out = 22),
as.character(1:22)))+
theme_classic() + theme(legend.position="none")+
scale_x_continuous(breaks=df2$center,labels=c(1:15,"",17,"",19,"",21,""))+
xlab("Chromosome")
Cairo::CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(mplot)
dev.off()
corSIV_dt
corSIV
head(corSIV)
head(df2)
head(dt)
## Add corSIV info (also on hg38)
corSIV <- readxl::read_excel("13059_2019_1708_MOESM1_ESM.xls",sheet = 3)
corSIV <- unique(corSIV$USCS_Coordinates_CoRSIV)
## Prepare corSIV_dt as an interval table
# Step 1: Parse corSIV into chromosome, start, end
corSIV_dt <- tstrsplit(corSIV, "[:-]", names = c("chr", "start", "end"))
corSIV_dt <- data.table(
chr = as.integer(sub("chr", "", corSIV_dt[[1]])),
start = as.integer(corSIV_dt[[2]]),
end = as.integer(corSIV_dt[[3]])
)
corSIV_dt
# Create an interval join-friendly table from dt
dt_subset <- dt[, .(chr = as.integer(chr), start_pos, end_pos)]
setkey(dt_subset, chr, start_pos, end_pos)
# Use foverlaps to find which entries in dt are in corSIVs
# Add row numbers to dt to mark matching entries
dt[, row_id := .I]
# Perform efficient interval overlap
overlap_idx <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)[, .(row_id)]
corSIV_dt
dt_subset
# Perform efficient interval overlap
overlap_idx <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)[, .(row_id)]
# Make sure corSIV_dt is keyed properly before foverlaps:
setkey(corSIV_dt, chr, start_pos, end_pos)
corSIV_dt
# Make sure corSIV_dt is keyed properly before foverlaps:
setkey(corSIV_dt, chr, start, end)
# Also key dt_subset, just in case
setkey(dt_subset, chr, start, end)
## Prepare corSIV_dt as an interval table
# Step 1: Parse corSIV into chromosome, start, end
corSIV_dt <- tstrsplit(corSIV, "[:-]", names = c("chr", "start", "end"))
corSIV_dt <- data.table(
chr = as.integer(sub("chr", "", corSIV_dt[[1]])),
start_pos = as.integer(corSIV_dt[[2]]),
end_pos = as.integer(corSIV_dt[[3]])
)
# Rename columns to match `foverlaps` convention
setkey(corSIV_dt, chr, start_pos, end_pos)
# Create an interval join-friendly table from dt
dt_subset <- dt[, .(chr = as.integer(chr), start_pos, end_pos)]
setkey(dt_subset, chr, start_pos, end_pos)
# Use foverlaps to find which entries in dt are in corSIVs
# Add row numbers to dt to mark matching entries
dt[, row_id := .I]
# Now run the overlap
overlap_idx <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)[, .(row_id)]
dt
# Now run the overlap
overlap_idx <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)[, .(row_id)]
# Use foverlaps to find which entries in dt are in corSIVs
# Add row numbers to dt to mark matching entries
dt_subset[, row_id := .I]
# Now run the overlap
overlap_idx <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)[, .(row_id)]
overlap_idx
# Flag those rows in original dt
dt[, in_corSIV := FALSE]
dt[overlap_idx$row_id, in_corSIV := TRUE]
plot <- ggplot() +
# Base points: all white
geom_point_rast(data = dt[in_corSIV == FALSE], aes(x = pos2, y = alpha),
color = "white", size = 0.3, alpha = 0.01, raster.dpi = 72) +
# Highlighted points: red, larger
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "red", size = 0.8, alpha = 0.1, raster.dpi = 72) +
# Background chromosome colors (optional)
scale_colour_manual(values = setNames(rep(c(colour1, colour2), length.out = 22),
as.character(1:22))) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center,
labels = c(1:15, "", 17, "", 19, "", 21, "")) +
xlab("Chromosome")
Cairo::CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(plot)
dev.off()
## July 2025
## A. Balard
## Plot files for scan Atlas
library(data.table)
library(progress)
library(ggplot2)
library(ggrastr)
library(patchwork)
library(readxl)
library(Cairo)
# Define parent folder containing all "Atlas_batchXXX" folders
parent_dir <- "resultsDir"
# Get list of relevant RData files
rdata_files <- dir(parent_dir, pattern = "results_Atlas_100000CpGs_0_8p0_0_65p1\\.RData$",
recursive = TRUE, full.names = TRUE)
all_cpg_values <- numeric()
pb <- progress_bar$new(total = length(rdata_files), format = "ðŸ“¦ :current/:total [:bar] :percent")
for (file in rdata_files) {
e <- new.env()
load(file, envir = e)
obj <- e[[ls(e)[1]]]
if (is.matrix(obj)) obj <- obj[, 1]
all_cpg_values <- c(all_cpg_values, obj)
pb$tick()
}
# Create data.table from named vector
dt <- data.table(
name = names(all_cpg_values),
alpha = as.numeric(all_cpg_values)
)
# Parse "chr_start-end" in name into chr, start_pos, end_pos
dt[, c("chr", "start_end") := tstrsplit(name, "_", fixed = TRUE)]
dt[, c("start_pos", "end_pos") := tstrsplit(start_end, "-", fixed = TRUE)]
dt[, `:=`(start_pos = as.integer(start_pos), end_pos = as.integer(end_pos))]
# Convert chr from "chrN" to integer factor
dt[, chr := as.integer(sub("chr", "", chr))]
dt[, chr := factor(chr, levels = 1:22)]
# Compute cumulative position offsets for Manhattan plot
setorder(dt, chr, start_pos)
offsets <- dt[, .(max_pos = max(start_pos, na.rm = TRUE)), by = chr]
offsets[, cum_offset := shift(cumsum(max_pos), fill = 0)]
dt <- merge(dt, offsets[, .(chr, cum_offset)], by = "chr", all.x = TRUE, sort = FALSE)
dt[, pos2 := start_pos + cum_offset]
# Compute chromosome centers for x-axis labeling
df2 <- dt[, .(center = mean(range(pos2, na.rm = TRUE))), by = chr]
df2 <- merge(data.frame(chr = factor(1:22, levels=1:22)), df2, by = "chr", all.x = TRUE, sort = TRUE)
# Load corSIV intervals
corSIV <- readxl::read_excel("13059_2019_1708_MOESM1_ESM.xls", sheet = 3)
corSIV <- unique(corSIV$USCS_Coordinates_CoRSIV)
# Parse corSIV to data.table with numeric chromosome, start, end
corSIV_split <- tstrsplit(corSIV, "[:-]", fixed = FALSE)
corSIV_dt <- data.table(
chr = as.integer(sub("chr", "", corSIV_split[[1]])),
start_pos = as.integer(corSIV_split[[2]]),
end_pos = as.integer(corSIV_split[[3]])
)
# Key the tables for foverlaps
setkey(corSIV_dt, chr, start_pos, end_pos)
dt_subset <- dt[, .(chr = as.integer(as.character(chr)), start_pos, end_pos)]
setkey(dt_subset, chr, start_pos, end_pos)
dt_subset[, row_id := .I]
# Find overlaps
overlaps <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)
overlap_idx <- overlaps[, row_id]
# Mark points in corSIV intervals
dt[, in_corSIV := FALSE]
dt[overlap_idx, in_corSIV := TRUE]
# Colors for chromosomes alternating
colour1 <- "#2e4057"
colour2 <- "#8c8c8c"
# Plot with base points black, highlighted points red and bigger
plot <- ggplot() +
geom_point_rast(data = dt[in_corSIV == FALSE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.01, raster.dpi = 72) +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "red", size = 0.8, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center,
labels = c(1:15, "", 17, "", 19, "", 21, "")) +
xlab("Chromosome")
# Save plot
CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(plot)
dev.off()
corSIV
# Plot with base points black, highlighted points red and bigger
plot <- ggplot() +
geom_point_rast(data = dt[in_corSIV == FALSE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.005, raster.dpi = 72) +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "red", size = 0.8, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center,
labels = c(1:15, "", 17, "", 19, "", 21, "")) +
xlab("Chromosome")
# Save plot
CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(plot)
dev.off()
dt
ggplot() +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.005, raster.dpi = 72)
ggplot() +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.05, raster.dpi = 72)
# Plot with base points black, highlighted points red and bigger
plot <- ggplot() +
geom_point_rast(data = dt[in_corSIV == FALSE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.005, raster.dpi = 72) +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "red", size = 1, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center,
labels = c(1:15, "", 17, "", 19, "", 21, "")) +
xlab("Chromosome")
# Save plot
CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(plot)
dev.off()
## July 2025
## A. Balard
## Plot files for scan Atlas
library(data.table)
library(progress)
library(ggplot2)
library(ggrastr)
library(patchwork)
library(readxl)
library(Cairo)
# Define parent folder containing all "Atlas_batchXXX" folders
parent_dir <- "resultsDir"
# Get list of relevant RData files
rdata_files <- dir(parent_dir, pattern = "results_Atlas_100000CpGs_0_8p0_0_65p1\\.RData$",
recursive = TRUE, full.names = TRUE)
all_cpg_values <- numeric()
pb <- progress_bar$new(total = length(rdata_files), format = "ðŸ“¦ :current/:total [:bar] :percent")
for (file in rdata_files) {
e <- new.env()
load(file, envir = e)
obj <- e[[ls(e)[1]]]
if (is.matrix(obj)) obj <- obj[, 1]
all_cpg_values <- c(all_cpg_values, obj)
pb$tick()
}
# Create data.table from named vector
dt <- data.table(
name = names(all_cpg_values),
alpha = as.numeric(all_cpg_values)
)
# Parse "chr_start-end" in name into chr, start_pos, end_pos
dt[, c("chr", "start_end") := tstrsplit(name, "_", fixed = TRUE)]
dt[, c("start_pos", "end_pos") := tstrsplit(start_end, "-", fixed = TRUE)]
dt[, `:=`(start_pos = as.integer(start_pos), end_pos = as.integer(end_pos))]
# Convert chr from "chrN" to integer factor
dt[, chr := as.integer(sub("chr", "", chr))]
dt[, chr := factor(chr, levels = 1:22)]
# Compute cumulative position offsets for Manhattan plot
setorder(dt, chr, start_pos)
offsets <- dt[, .(max_pos = max(start_pos, na.rm = TRUE)), by = chr]
offsets[, cum_offset := shift(cumsum(max_pos), fill = 0)]
dt <- merge(dt, offsets[, .(chr, cum_offset)], by = "chr", all.x = TRUE, sort = FALSE)
dt[, pos2 := start_pos + cum_offset]
# Compute chromosome centers for x-axis labeling
df2 <- dt[, .(center = mean(range(pos2, na.rm = TRUE))), by = chr]
df2 <- merge(data.frame(chr = factor(1:22, levels=1:22)), df2, by = "chr", all.x = TRUE, sort = TRUE)
# Load corSIV intervals
corSIV <- readxl::read_excel("13059_2019_1708_MOESM1_ESM.xls", sheet = 3)
corSIV <- unique(corSIV$USCS_Coordinates_CoRSIV)
# Parse corSIV to data.table with numeric chromosome, start, end
corSIV_split <- tstrsplit(corSIV, "[:-]", fixed = FALSE)
corSIV_dt <- data.table(
chr = as.integer(sub("chr", "", corSIV_split[[1]])),
start_pos = as.integer(corSIV_split[[2]]),
end_pos = as.integer(corSIV_split[[3]])
)
# Key the tables for foverlaps
setkey(corSIV_dt, chr, start_pos, end_pos)
dt_subset <- dt[, .(chr = as.integer(as.character(chr)), start_pos, end_pos)]
setkey(dt_subset, chr, start_pos, end_pos)
dt_subset[, row_id := .I]
# Find overlaps
overlaps <- foverlaps(dt_subset, corSIV_dt, nomatch = 0L)
overlap_idx <- overlaps[, row_id]
# Mark points in corSIV intervals
dt[, in_corSIV := FALSE]
dt[overlap_idx, in_corSIV := TRUE]
# Plot with base points black, highlighted points red and bigger
plot <- ggplot() +
geom_point_rast(data = dt[in_corSIV == FALSE], aes(x = pos2, y = alpha),
color = "black", size = 0.3, alpha = 0.005, raster.dpi = 72) +
geom_point_rast(data = dt[in_corSIV == TRUE], aes(x = pos2, y = alpha),
color = "red", size = 1, alpha = 0.1, raster.dpi = 72) +
theme_classic() + theme(legend.position = "none") +
scale_x_continuous(breaks = df2$center,
labels = c(1:15, "", 17, "", 19, "", 21, "")) +
xlab("Chromosome")
# Save plot
CairoPNG("ManhattanAlphaPlot.png", width = 1600, height = 600)
print(plot)
dev.off()
# Create binary column for alpha > 0.7
dt[, alpha_high := alpha > 0.7]
# Count combinations of (in_corSIV, alpha_high)
tbl <- dt[, .N, by = .(in_corSIV, alpha_high)]
A <- tbl[in_corSIV == TRUE & alpha_high == TRUE, N]
B <- tbl[in_corSIV == FALSE & alpha_high == TRUE, N]
C <- tbl[in_corSIV == TRUE & alpha_high == FALSE, N]
D <- tbl[in_corSIV == FALSE & alpha_high == FALSE, N]
# Replace missing counts with zero
A <- ifelse(length(A) == 0, 0, A)
B <- ifelse(length(B) == 0, 0, B)
C <- ifelse(length(C) == 0, 0, C)
D <- ifelse(length(D) == 0, 0, D)
# Build matrix
contingency_matrix <- matrix(c(A, B, C, D), nrow = 2, byrow = TRUE,
dimnames = list(`Alpha > 0.6` = c("Yes", "No"),
`In corSIV` = c("Yes", "No")))
# Perform Fisher's Exact Test
fisher_result <- fisher.test(contingency_matrix)
# View result
print(contingency_matrix)
print(fisher_result)
threshold=0.7
# Create binary column for alpha > threshold
dt[, alpha_high := alpha > threshold]
# Count combinations of (in_corSIV, alpha_high)
tbl <- dt[, .N, by = .(in_corSIV, alpha_high)]
A <- tbl[in_corSIV == TRUE & alpha_high == TRUE, N]
B <- tbl[in_corSIV == FALSE & alpha_high == TRUE, N]
C <- tbl[in_corSIV == TRUE & alpha_high == FALSE, N]
D <- tbl[in_corSIV == FALSE & alpha_high == FALSE, N]
# Replace missing counts with zero
A <- ifelse(length(A) == 0, 0, A)
B <- ifelse(length(B) == 0, 0, B)
C <- ifelse(length(C) == 0, 0, C)
D <- ifelse(length(D) == 0, 0, D)
# Build matrix
contingency_matrix <- matrix(c(A, B, C, D), nrow = 2, byrow = TRUE,
dimnames = list(`Alpha > threshold` = c("Yes", "No"),
`In corSIV` = c("Yes", "No")))
# Perform Fisher's Exact Test
fisher_result <- fisher.test(contingency_matrix)
# View result
print(contingency_matrix)
print(fisher_result)
#
threshold=0.6
# Create binary column for alpha > threshold
dt[, alpha_high := alpha > threshold]
# Count combinations of (in_corSIV, alpha_high)
tbl <- dt[, .N, by = .(in_corSIV, alpha_high)]
A <- tbl[in_corSIV == TRUE & alpha_high == TRUE, N]
B <- tbl[in_corSIV == FALSE & alpha_high == TRUE, N]
C <- tbl[in_corSIV == TRUE & alpha_high == FALSE, N]
D <- tbl[in_corSIV == FALSE & alpha_high == FALSE, N]
# Replace missing counts with zero
A <- ifelse(length(A) == 0, 0, A)
B <- ifelse(length(B) == 0, 0, B)
C <- ifelse(length(C) == 0, 0, C)
D <- ifelse(length(D) == 0, 0, D)
# Build matrix
contingency_matrix <- matrix(c(A, B, C, D), nrow = 2, byrow = TRUE,
dimnames = list(`Alpha > threshold` = c("Yes", "No"),
`In corSIV` = c("Yes", "No")))
# Perform Fisher's Exact Test
fisher_result <- fisher.test(contingency_matrix)
# View result
print(contingency_matrix)
print(fisher_result)
threshold=0.7
# Create binary column for alpha > threshold
dt[, alpha_high := alpha > threshold]
# Count combinations of (in_corSIV, alpha_high)
tbl <- dt[, .N, by = .(in_corSIV, alpha_high)]
A <- tbl[in_corSIV == TRUE & alpha_high == TRUE, N]
B <- tbl[in_corSIV == FALSE & alpha_high == TRUE, N]
C <- tbl[in_corSIV == TRUE & alpha_high == FALSE, N]
D <- tbl[in_corSIV == FALSE & alpha_high == FALSE, N]
# Replace missing counts with zero
A <- ifelse(length(A) == 0, 0, A)
B <- ifelse(length(B) == 0, 0, B)
C <- ifelse(length(C) == 0, 0, C)
D <- ifelse(length(D) == 0, 0, D)
# Build matrix
contingency_matrix <- matrix(c(A, B, C, D), nrow = 2, byrow = TRUE,
dimnames = list(`Alpha > threshold` = c("Yes", "No"),
`In corSIV` = c("Yes", "No")))
# Perform Fisher's Exact Test
fisher_result <- fisher.test(contingency_matrix)
# View result
print(contingency_matrix)
print(fisher_result)
