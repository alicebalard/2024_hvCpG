meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
p3 <- plotMyVenn(0.9, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
pdf(file = paste0("../../05_hvCpGalgorithm/figures/vennGermLayers/Venn_",
name, "_GR.pdf"), width = 13, height = 6)
print(cowplot::plot_grid(p1 + theme(legend.position = "none"),
p2 + theme(legend.position = "none"),
p3 + theme(legend.position = "none"),
nrow = 1, labels = name))
dev.off()
})
##############################################################
## Are these hvCpG detected also in individual germ layers? ##
##############################################################
gr_list <- list(cellUniversal = cellUniversal_GR,
immune = immune_GR,
notimmune = notimmune_GR,
stable = stable_GR)
gr_list <- list(stable = stable_GR)
lapply(names(gr_list), function(name){
x <- gr_list[[name]]
gr_names <- paste0(as.character(seqnames(x)), "_", start(x))
p1 <- plotMyVenn(0.5, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
p2 <- plotMyVenn(0.75, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
p3 <- plotMyVenn(0.9, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
pdf(file = paste0("../../05_hvCpGalgorithm/figures/vennGermLayers/Venn_",
name, "_GR.pdf"), width = 13, height = 6)
print(cowplot::plot_grid(p1 + theme(legend.position = "none"),
p2 + theme(legend.position = "none"),
p3 + theme(legend.position = "none"),
nrow = 1, labels = name))
dev.off()
})
###########################################
## Find them in each quadrants
hits <- GenomicRanges::findOverlaps(cellUniversal_GR, putativeME_GR)
DerakhshanhvCpGs_hg38_GR
gr_list <- list(cellUniversal = cellUniversal_GR,
immune = immune_GR,
notimmune = notimmune_GR,
stable = stable_GR,
DerakhshanhvCpGs = DerakhshanhvCpGs_hg38_GR)
gr_list <- list(                DerakhshanhvCpGs = DerakhshanhvCpGs_hg38_GR)
lapply(names(gr_list), function(name){
x <- gr_list[[name]]
gr_names <- paste0(as.character(seqnames(x)), "_", start(x))
p1 <- plotMyVenn(0.5, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
p2 <- plotMyVenn(0.75, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
p3 <- plotMyVenn(0.9, endo = endo[endo$name %in% gr_names,],
meso = meso[meso$name %in% gr_names,],
ecto = ecto[ecto$name %in% gr_names,],
all = allLayers[allLayers$name %in% gr_names,])
pdf(file = paste0("../../05_hvCpGalgorithm/figures/vennGermLayers/Venn_",
name, "_GR.pdf"), width = 13, height = 6)
print(cowplot::plot_grid(p1 + theme(legend.position = "none"),
p2 + theme(legend.position = "none"),
p3 + theme(legend.position = "none"),
nrow = 1, labels = name))
dev.off()
})
allLayers
## Test enrichement of the most likely germ layer-universal hvCpG in previous MEs
total <- Reduce(intersect, c(allLayers$name, endo$name, meso$name, ecto$name))
meso[alpha > 0.9, name]][
## Test enrichement of the most likely germ layer-universal hvCpG in previous MEs
top_cpgs <- allLayers[alpha > 0.9, name][
endo[alpha > 0.9, name]][
meso[alpha > 0.9, name]][
ecto[alpha > 0.9, name]]
top_cpgs
allLayers[alpha > 0.9, name]
allLayers[alpha > 0.9, name][
endo[alpha > 0.9, name]]
allLayers[alpha > 0.9, name]
## Test enrichement of the most likely germ layer-universal hvCpG in previous MEs
total <- allLayers$name[allLayers$name %in% endo$name]
total <- total[total %in% meso$name]
total <- total[total %in% ecto$name]
total
top_cpgs <- allLayers[alpha > 0.9, name]
top_cpgs
top_cpgs <- top_cpgs[endo[alpha > 0.9, name]]
top_cpgs
# Check each step
step1 <- allLayers[alpha > 0.9, name]    # should have elements
step2 <- endo[alpha > 0.9, name]
step3 <- meso[alpha > 0.9, name]
step4 <- ecto[alpha > 0.9, name]
print(length(step1))  # non-zero?
print(length(step2))  # non-zero?
print(any(step1 %in% step2))  # FALSE = no overlap
# Test pairwise intersection
intersect(step1, step2)  # empty?
names(allLayers)  # has "alpha"?
names(endo)       # has "alpha"?
# Check if ANY high-alpha CpGs overlap
any(allLayers$name[allLayers$alpha > 0.9] %in%
endo$name[endo$alpha > 0.9])
class(allLayers$name)  # "character"?
class(endo$name)       # same?
# Convert to character first, handle empty results
top_cpgs <- intersect(
intersect(
as.character(allLayers$name[allLayers$alpha > 0.9]),
as.character(endo$name[endo$alpha > 0.9])
),
intersect(
as.character(meso$name[meso$alpha > 0.9]),
as.character(ecto$name[ecto$alpha > 0.9])
)
)
print(paste("Found", length(top_cpgs), "overlapping high-alpha CpGs"))
top_cpgs
top_cpgs <- intersect(
intersect(allLayers$name[allLayers$alpha > 0.9], endo$name[endo$alpha > 0.9]),
intersect(meso$name[meso$alpha > 0.9],ecto$name[ecto$alpha > 0.9]))
print(paste("Found", length(top_cpgs), "overlapping high-alpha CpGs"))
total
set <- list(top_cpgs = top_cpgs, total = total)
allLayers
allLayers[allLayers$name %in% total]
set <- list(top_cpgs = allLayers[allLayers$name %in% top_cpgs],
total = allLayers[allLayers$name %in% total])
nrow(set$top_cpgs )
nrow(set$total )
# --- Helper: safe Fisher with edge cases (all zeros, etc.)
.safe_fisher <- function(a, b, c, d) {
mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
dimnames = list(c("this_quadrant","others"), c("inME","notME")))
# If any row or column totals are zero, Fisher’s test is not defined
if (any(rowSums(mat) == 0) || any(colSums(mat) == 0)) {
return(list(or = NA_real_, p = NA_real_))
} else {
ft <- fisher.test(mat)
return(list(or = unname(ft$estimate), p = ft$p.value))
}
}
# --- Main: test enrichment of ME for each quadrant vs the other three combined
test_enrichment_quadrants <- function(quad_list, putativeME_GR, me_col = "set") {
# If no 'set' column, treat all ME as one group "ALL"
if (!(me_col %in% names(mcols(putativeME_GR)))) {
me_sets <- "ALL"
putativeME_GR$..tmp_set.. <- "ALL"
me_col <- "..tmp_set.."
} else {
me_sets <- unique(as.character(mcols(putativeME_GR)[[me_col]]))
}
# Total elements per quadrant (each element counted once)
totals <- vapply(quad_list, length, integer(1))
# Iterate over ME sets
out <- lapply(me_sets, function(me_name) {
me_subset <- putativeME_GR[mcols(putativeME_GR)[[me_col]] == me_name]
# Count how many elements in each quadrant overlap the ME subset
inME <- vapply(quad_list, function(gr) {
ov <- findOverlaps(gr, me_subset, ignore.strand = TRUE)
length(unique(queryHits(ov)))  # number of quadrant elements hitting at least one ME
}, integer(1))
# Build quadrant-vs-others 2x2 tests
bind_rows(lapply(names(quad_list), function(q) {
a <- inME[[q]]
b <- totals[[q]] - a
c <- sum(inME[names(inME) != q])
d <- sum(totals[names(totals) != q]) - c
fs <- .safe_fisher(a, b, c, d)
tibble(
ME_set            = me_name,
quadrant          = q,
inME              = a,
total             = totals[[q]],
others_inME       = c,
others_total      = sum(totals) - totals[[q]],
pct_inME          = 100 * a / totals[[q]],
pct_inME_others   = 100 * c / (sum(totals) - totals[[q]]),
odds_ratio        = fs$or,
p_value           = fs$p
)
}))
}) %>% bind_rows() %>%
mutate(p_adj_BH = p.adjust(p_value, method = "BH"))
out
}
# ---- Run it (ME sets in putativeME_GR$set will be tested separately)
res_quadrants <- test_enrichment_quadrants(set, putativeME_GR, me_col = "set")
set
putativeME_GR
listGR <- list(top_cpgs = allLayers[allLayers$name %in% top_cpgs],
total = allLayers[allLayers$name %in% total])
# --- Helper: safe Fisher with edge cases (all zeros, etc.)
.safe_fisher <- function(a, b, c, d) {
mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
dimnames = list(c("this_quadrant","others"), c("inME","notME")))
# If any row or column totals are zero, Fisher’s test is not defined
if (any(rowSums(mat) == 0) || any(colSums(mat) == 0)) {
return(list(or = NA_real_, p = NA_real_))
} else {
ft <- fisher.test(mat)
return(list(or = unname(ft$estimate), p = ft$p.value))
}
}
# --- Main: test enrichment of ME for each quadrant vs the other three combined
test_enrichment_quadrants <- function(quad_list, putativeME_GR, me_col = "set") {
# If no 'set' column, treat all ME as one group "ALL"
if (!(me_col %in% names(mcols(putativeME_GR)))) {
me_sets <- "ALL"
putativeME_GR$..tmp_set.. <- "ALL"
me_col <- "..tmp_set.."
} else {
me_sets <- unique(as.character(mcols(putativeME_GR)[[me_col]]))
}
# Total elements per quadrant (each element counted once)
totals <- vapply(quad_list, length, integer(1))
# Iterate over ME sets
out <- lapply(me_sets, function(me_name) {
me_subset <- putativeME_GR[mcols(putativeME_GR)[[me_col]] == me_name]
# Count how many elements in each quadrant overlap the ME subset
inME <- vapply(quad_list, function(gr) {
ov <- findOverlaps(gr, me_subset, ignore.strand = TRUE)
length(unique(queryHits(ov)))  # number of quadrant elements hitting at least one ME
}, integer(1))
# Build quadrant-vs-others 2x2 tests
bind_rows(lapply(names(quad_list), function(q) {
a <- inME[[q]]
b <- totals[[q]] - a
c <- sum(inME[names(inME) != q])
d <- sum(totals[names(totals) != q]) - c
fs <- .safe_fisher(a, b, c, d)
tibble(
ME_set            = me_name,
quadrant          = q,
inME              = a,
total             = totals[[q]],
others_inME       = c,
others_total      = sum(totals) - totals[[q]],
pct_inME          = 100 * a / totals[[q]],
pct_inME_others   = 100 * c / (sum(totals) - totals[[q]]),
odds_ratio        = fs$or,
p_value           = fs$p
)
}))
}) %>% bind_rows() %>%
mutate(p_adj_BH = p.adjust(p_value, method = "BH"))
out
}
# ---- Run it (ME sets in putativeME_GR$set will be tested separately)
res_quadrants <- test_enrichment_quadrants(listGR, putativeME_GR, me_col = "set")
allLayers
listGR$top_cpgs
class(listGR$top_cpgs)
class(allLayers)
listGR <- list(
top_cpgs = makeGRangesFromDataFrame(
allLayers[allLayers$name %in% top_cpgs, .(seqnames, start, end)],
keep.extra.columns = TRUE
),
total = makeGRangesFromDataFrame(
allLayers[allLayers$name %in% total, .(seqnames, start, end)],
keep.extra.columns = TRUE
)
)
makeGRangesFromDataFrame(
allLayers[allLayers$name %in% top_cpgs, .(seqnames, start, end)],
keep.extra.columns = TRUE
)
allLayers[allLayers$name %in% top_cpgs
vmeQTL_hg38
vmeQTL_hg38
listGR <- list(top_cpgs = makeGRfromMyCpGPos(top_cpgs),
total = makeGRangesFromDataFrame(total))
listGR <- list(top_cpgs = makeGRfromMyCpGPos(top_cpgs, "topCpGs"),
total = makeGRangesFromDataFrame(total, "totalCpGs"))
makeGRfromMyCpGPos(vec = top_cpgs, setname = "topCpGs")
listGR <- list(top_cpgs = makeGRfromMyCpGPos(vec = top_cpgs, setname = "topCpGs"),
total = makeGRfromMyCpGPos(total, "totalCpGs"))
# --- Helper: safe Fisher with edge cases (all zeros, etc.)
.safe_fisher <- function(a, b, c, d) {
mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
dimnames = list(c("this_quadrant","others"), c("inME","notME")))
# If any row or column totals are zero, Fisher’s test is not defined
if (any(rowSums(mat) == 0) || any(colSums(mat) == 0)) {
return(list(or = NA_real_, p = NA_real_))
} else {
ft <- fisher.test(mat)
return(list(or = unname(ft$estimate), p = ft$p.value))
}
}
# --- Main: test enrichment of ME for each quadrant vs the other three combined
test_enrichment_quadrants <- function(quad_list, putativeME_GR, me_col = "set") {
# If no 'set' column, treat all ME as one group "ALL"
if (!(me_col %in% names(mcols(putativeME_GR)))) {
me_sets <- "ALL"
putativeME_GR$..tmp_set.. <- "ALL"
me_col <- "..tmp_set.."
} else {
me_sets <- unique(as.character(mcols(putativeME_GR)[[me_col]]))
}
# Total elements per quadrant (each element counted once)
totals <- vapply(quad_list, length, integer(1))
# Iterate over ME sets
out <- lapply(me_sets, function(me_name) {
me_subset <- putativeME_GR[mcols(putativeME_GR)[[me_col]] == me_name]
# Count how many elements in each quadrant overlap the ME subset
inME <- vapply(quad_list, function(gr) {
ov <- findOverlaps(gr, me_subset, ignore.strand = TRUE)
length(unique(queryHits(ov)))  # number of quadrant elements hitting at least one ME
}, integer(1))
# Build quadrant-vs-others 2x2 tests
bind_rows(lapply(names(quad_list), function(q) {
a <- inME[[q]]
b <- totals[[q]] - a
c <- sum(inME[names(inME) != q])
d <- sum(totals[names(totals) != q]) - c
fs <- .safe_fisher(a, b, c, d)
tibble(
ME_set            = me_name,
quadrant          = q,
inME              = a,
total             = totals[[q]],
others_inME       = c,
others_total      = sum(totals) - totals[[q]],
pct_inME          = 100 * a / totals[[q]],
pct_inME_others   = 100 * c / (sum(totals) - totals[[q]]),
odds_ratio        = fs$or,
p_value           = fs$p
)
}))
}) %>% bind_rows() %>%
mutate(p_adj_BH = p.adjust(p_value, method = "BH"))
out
}
# ---- Run it (ME sets in putativeME_GR$set will be tested separately)
res_quadrants <- test_enrichment_quadrants(listGR, putativeME_GR, me_col = "set")
# Order quadrants within each facet by log2OR
res_plot2 <- res_quadrants %>%
mutate(
log2OR       = log2(odds_ratio),
signif  = p_adj_BH < 0.05
) %>%
group_by(ME_set) %>%
mutate(quadrant_ord = reorder(quadrant, log2OR)) %>%
ungroup()
plot <- ggplot(res_plot2, aes(x = quadrant_ord, y = log2OR, fill = signif)) +
geom_col(width = 0.8) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
scale_fill_manual(values = c("grey", "black")) +
labs(
x = "Quadrant",
y = expression(log[2]~"(odds ratio)"),
title = "ME enrichment by quadrant (vs other three quadrants)",
subtitle = "Bars ordered by effect within ME set; dashed line = OR = 1"
) +
facet_wrap(~ ME_set, scales = "free_x", nrow = 1) +
theme_classic(base_size = 10) +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
legend.position = "right",
strip.background = element_rect(fill = "white"),
strip.text = element_text(face = "bold")
)
pdf(here("05_hvCpGalgorithm/figures/topCpGsEnrichME.pdf"), width = 12, height = 6)
plot
dev.off()
listGR <- list(top90 = makeGRfromMyCpGPos(vec = top_cpgs, setname = "topCpGs"),
allButTop90 = makeGRfromMyCpGPos(total[!total %in% top_cpgs], "allButTop90"))
# --- Helper: safe Fisher with edge cases (all zeros, etc.)
.safe_fisher <- function(a, b, c, d) {
mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
dimnames = list(c("this_quadrant","others"), c("inME","notME")))
# If any row or column totals are zero, Fisher’s test is not defined
if (any(rowSums(mat) == 0) || any(colSums(mat) == 0)) {
return(list(or = NA_real_, p = NA_real_))
} else {
ft <- fisher.test(mat)
return(list(or = unname(ft$estimate), p = ft$p.value))
}
}
# --- Main: test enrichment of ME for each quadrant vs the other three combined
test_enrichment_quadrants <- function(quad_list, putativeME_GR, me_col = "set") {
# If no 'set' column, treat all ME as one group "ALL"
if (!(me_col %in% names(mcols(putativeME_GR)))) {
me_sets <- "ALL"
putativeME_GR$..tmp_set.. <- "ALL"
me_col <- "..tmp_set.."
} else {
me_sets <- unique(as.character(mcols(putativeME_GR)[[me_col]]))
}
# Total elements per quadrant (each element counted once)
totals <- vapply(quad_list, length, integer(1))
# Iterate over ME sets
out <- lapply(me_sets, function(me_name) {
me_subset <- putativeME_GR[mcols(putativeME_GR)[[me_col]] == me_name]
# Count how many elements in each quadrant overlap the ME subset
inME <- vapply(quad_list, function(gr) {
ov <- findOverlaps(gr, me_subset, ignore.strand = TRUE)
length(unique(queryHits(ov)))  # number of quadrant elements hitting at least one ME
}, integer(1))
# Build quadrant-vs-others 2x2 tests
bind_rows(lapply(names(quad_list), function(q) {
a <- inME[[q]]
b <- totals[[q]] - a
c <- sum(inME[names(inME) != q])
d <- sum(totals[names(totals) != q]) - c
fs <- .safe_fisher(a, b, c, d)
tibble(
ME_set            = me_name,
quadrant          = q,
inME              = a,
total             = totals[[q]],
others_inME       = c,
others_total      = sum(totals) - totals[[q]],
pct_inME          = 100 * a / totals[[q]],
pct_inME_others   = 100 * c / (sum(totals) - totals[[q]]),
odds_ratio        = fs$or,
p_value           = fs$p
)
}))
}) %>% bind_rows() %>%
mutate(p_adj_BH = p.adjust(p_value, method = "BH"))
out
}
# ---- Run it (ME sets in putativeME_GR$set will be tested separately)
res_quadrants <- test_enrichment_quadrants(listGR, putativeME_GR, me_col = "set")
# Order quadrants within each facet by log2OR
res_plot2 <- res_quadrants %>%
mutate(
log2OR       = log2(odds_ratio),
signif  = p_adj_BH < 0.05
) %>%
group_by(ME_set) %>%
mutate(quadrant_ord = reorder(quadrant, log2OR)) %>%
ungroup()
plot <- ggplot(res_plot2, aes(x = quadrant_ord, y = log2OR, fill = signif)) +
geom_col(width = 0.8) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
scale_fill_manual(values = c("grey", "black")) +
labs(
x = "Quadrant",
y = expression(log[2]~"(odds ratio)"),
title = "ME enrichment by quadrant (vs other three quadrants)",
subtitle = "Bars ordered by effect within ME set; dashed line = OR = 1"
) +
facet_wrap(~ ME_set, scales = "free_x", nrow = 1) +
theme_classic(base_size = 10) +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
legend.position = "right",
strip.background = element_rect(fill = "white"),
strip.text = element_text(face = "bold")
)
pdf(here("05_hvCpGalgorithm/figures/topCpGsEnrichME.pdf"), width = 12, height = 6)
plot
dev.off()
plot <- ggplot(res_plot2, aes(x = quadrant_ord, y = log2OR, fill = signif)) +
geom_col(width = 0.8) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
scale_fill_manual(values = c("grey", "black")) +
labs(
x = NULL,
y = expression(log[2]~"(odds ratio)"),
title = "ME enrichment by quadrant (vs other three quadrants)",
subtitle = "Bars ordered by effect within ME set; dashed line = OR = 1"
) +
facet_wrap(~ ME_set, scales = "free_x", nrow = 1) +
theme_classic(base_size = 10) +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
legend.position = "right",
strip.background = element_rect(fill = "white"),
strip.text = element_text(face = "bold")
)
pdf(here("05_hvCpGalgorithm/figures/topCpGsEnrichME.pdf"), width = 12, height = 6)
plot
dev.off()
plot <- ggplot(res_plot2, aes(x = quadrant_ord, y = log2OR, fill = signif)) +
geom_col(width = 0.8) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
scale_fill_manual(values = c("grey", "black")) +
labs(
x = NULL,
y = expression(log[2]~"(odds ratio)"),
title = "ME enrichment by group (vs other group)",
subtitle = "Bars ordered by effect within ME set; dashed line = OR = 1"
) +
facet_wrap(~ ME_set, scales = "free_x", nrow = 1) +
theme_classic(base_size = 10) +
theme(
axis.text.x = element_text(angle = 30, hjust = 1),
legend.position = "right",
strip.background = element_rect(fill = "white"),
strip.text = element_text(face = "bold")
)
pdf(here("05_hvCpGalgorithm/figures/topCpGsEnrichME.pdf"), width = 12, height = 6)
plot
dev.off()
